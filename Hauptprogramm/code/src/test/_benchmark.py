# import random
# import string
# from dataclasses import dataclass, field
#
#
# # 1x _ bedeutet private   = _search_string  (private)
# # 2x _ bedeutet protected = __search_string (protected)
#
# def generate_id() -> str:
#     return "".join(random.choices(string.ascii_uppercase, k=12))
#
#
# # dataclass needs to be added @dataclass(frozen=False) # wenn frozen = True, dann kann man die Variablen nach der
# # Initialisierung nicht mehr Ã¤ndern (d.h. fehler meldungen werden geworfen beim versuch)
# # @dataclass(kw_only=True, # slots=True) # kw_only bedeutet beim aufrufen muss man filname= hinschreiben und slots
# # macht das Programm schneller
# @dataclass
# class Benchmark:
#     fileName: str
#     timeLimit: str
#     # active: bool = True # boolean
#     # email_addresses: list[str] = field(default_factory=list) # list of string
#     # id: str = field(init=False, default_factory=generate_id)
#     # _search_string: str = field(init=False, repr=False) # repr = false bedeutet es wird nicht ausgegeben
#
#     # def __post_init__(self) -> None:
#     #     self._search_string = f"{self.filename} {self.timelimit}"
#
#     # this will be generated by the dataclass
#     # def __init__(self, filename: str, timelimit: str):
#     #    self.filename = filename
#     #    self.timelimit = timelimit
#     #
#     # def __str__(self) -> str:
#     #    return f"{self.filename}, {self.timelimit}"
#
# # def main() -> None:
# #     benchmark = Benchmark(filename="benchmark.txt", timelimit="30s")
# #     benchmark2 = Benchmark(filename="benchmark.txt", timelimit="30s", active=False)
# #     print()
# #     print(benchmark)
# #     print(benchmark2)
#
# # if __name__ == "__main__":
# #     main()
